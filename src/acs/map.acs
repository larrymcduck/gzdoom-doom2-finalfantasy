#library "map"
#include "zcommon.acs"
#import "vars.acs"
#import "map01_world.acs"

world int 1:currentMapNum;
world int 2:nextMap;

world int 3:heroX;
world int 4:heroY;
world int 5:worldMapX;
world int 6:worldMapY;

int nextMapX = 0;
int nextMapY = 0;
int canMoveUp = 1;
int canMoveDown = 1;
int canMoveLeft = 1;
int canMoveRight = 1;
int canMoveUpRight = 1;
int canMoveDownRight = 1;
int canMoveUpLeft = 1;
int canMoveDownLeft = 1;

int mapDisplayX = 0;
int mapDisplayY = 0;

int mapCoordinateX = 0;
int mapCoordinateY = 0;

int mapSize = 0;
str map = "";

str heroMap = "fi";
str heroDirection = "d";
int heroMapState = 1;
int heroMapStateTics = 0;

bool canHeroMove = true;

int moveX = 0;
int moveY = 0;

int moveSpeed = 4;

function void clear_graphic_layer(int layer)
{
    HudMessage(s:""; HUDMSG_PLAIN, layer, "CR_UNTRANSLATED", 0.0, 0.0, 0);
}

function void show_map(void)
{
    mapSize = get_map_size();
    map = get_map_graphic();

    heroX = GetActorX(0) >> 16;
    heroY = GetActorY(0) >> 16;

    mapDisplayX = ((mapSize / 2) + hudHalfWidth - (((GetActorX(0) / 32) * 16) >> 16)) << 16;
    mapDisplayY = ((mapSize / 2) + hudHalfHeight + (((GetActorY(0) / 32) * 16) >> 16)) << 16;

    SetHudSize(320, 240, FALSE);

    show_graphic(map, MAP_LAYER, mapDisplayX, mapDisplayY);
    show_graphic(map, MAP_LAYER + 1, mapDisplayX - (mapSize << 16), mapDisplayY - (mapSize << 16));
    show_graphic(map, MAP_LAYER + 2, mapDisplayX, mapDisplayY - (mapSize << 16));
    show_graphic(map, MAP_LAYER + 3, mapDisplayX + (mapSize << 16), mapDisplayY - (mapSize << 16));
    show_graphic(map, MAP_LAYER + 4, mapDisplayX - (mapSize << 16), mapDisplayY);
    show_graphic(map, MAP_LAYER + 5, mapDisplayX + (mapSize << 16), mapDisplayY);
    show_graphic(map, MAP_LAYER + 6, mapDisplayX - (mapSize << 16), mapDisplayY + (mapSize << 16));
    show_graphic(map, MAP_LAYER + 7, mapDisplayX, mapDisplayY + (mapSize << 16));
    show_graphic(map, MAP_LAYER + 8, mapDisplayX + (mapSize << 16), mapDisplayY + (mapSize << 16));

    str heroMapSprite = StrParam(s:heroMap, s:"_map", s:heroDirection, d:heroMapState);
    show_graphic(heroMapSprite, HERO_MAP_LAYER, (hudHalfWidth << 16), ((hudHalfHeight - 3) << 16));

    map_objects();
    hero_map_movement();
}

function void check_movement(void) {
    SetActorAngle(0, 0.0);
    canMoveRight = Spawn("WallCheck", GetActorX(0) + 32.0, GetActorY(0), 0.0);
    canMoveLeft = Spawn("WallCheck", GetActorX(0) - 32.0, GetActorY(0), 0.0);
    canMoveDown = Spawn("WallCheck", GetActorX(0), GetActorY(0) - 32.0, 0.0);
    canMoveUp = Spawn("WallCheck", GetActorX(0), GetActorY(0) + 32.0, 0.0);

    canMoveUpRight = Spawn("WallCheck", GetActorX(0) + 32.0, GetActorY(0) + 32.0, 0.0);
    canMoveDownRight = Spawn("WallCheck", GetActorX(0) + 32.0, GetActorY(0) - 32.0, 0.0);
    canMoveUpLeft = Spawn("WallCheck", GetActorX(0) - 32.0, GetActorY(0) + 32.0, 0.0);
    canMoveDownLeft = Spawn("WallCheck", GetActorX(0) - 32.0, GetActorY(0) - 32.0, 0.0);
}

function void check_map_loop(void)
{
    int newX = GetActorX(0);
    int newY = GetActorY(0);
    int newZ = GetActorZ(0);
    if (newX == (-16 << 16))
    {
        newX = ((mapSize * 2) - 16) << 16;
    }

    if (newX == ((mapSize * 2) + 16) << 16)
    {
        newX = (16 << 16);
    }

    if (newY == (16 << 16))
    {
        newY = -(((mapSize * 2) - 16) << 16);
    }

    if (newY == -(((mapSize * 2) + 16) << 16))
    {
        newY = (16 << 16);
    }

    SetActorPosition(0, newX, newY, newZ, 0);
}

function void hero_map_movement(void)
{
    Thing_Stop(0);
    if (!screenChanging)
    {
        check_map_points();
    }

    if (canHeroMove)
    {
        canHeroMove = false;
        check_map_loop();
        check_movement();
        int buttons = GetPlayerInput(0, INPUT_BUTTONS);

        if ((buttons & BT_FORWARD) && !(buttons & BT_BACK) && canMoveUp)  // move up
        {
            heroDirection = "u";
            moveY++;
        }
        if ((buttons & BT_BACK) && !(buttons & BT_FORWARD) && canMoveDown)  // move down
        {
            heroDirection = "d";
            moveY--;
        }

        if ((buttons & BT_MOVELEFT) && !(buttons & BT_MOVERIGHT) && canMoveLeft)  // move left
        {
            heroDirection = "l";
            moveX--;
        }
        if ((buttons & BT_MOVERIGHT) && !(buttons & BT_MOVELEFT) && canMoveRight)  // move right
        {
            heroDirection = "r";
            moveX++;
        }

        if (moveY == 1 && ((buttons & BT_MOVELEFT) || (buttons & BT_MOVERIGHT)))  // up
        {
            if ((moveX == -1 && !canMoveUpLeft) || (moveX == 1 && !canMoveUpRight))
            {
                heroDirection = "u";
                moveX = 0;
            }
        }
        else if (moveY == -1 && ((buttons & BT_MOVELEFT) || (buttons & BT_MOVERIGHT)))  // down
        {
            if ((moveX == -1 && !canMoveDownLeft) || (moveX == 1 && !canMoveDownRight))
            {
                heroDirection = "d";
                moveX = 0;
            }
        }

        if (moveX == -1 && ((buttons & BT_FORWARD) || (buttons & BT_BACK)))  // left
        {
            if ((moveY == -1 && !canMoveDownLeft) || (moveY == 1 && !canMoveUpLeft))
            {
                heroDirection = "l";
                moveY = 0;
            }
        }
        else if (moveX == 1 && ((buttons & BT_FORWARD) || (buttons & BT_BACK)))  // right
        {
            if ((moveY == -1 && !canMoveDownRight) || (moveY == 1 && !canMoveUpRight))
            {
                heroDirection = "r";
                moveY = 0;
            }
        }

        nextMapX = GetActorX(0) + ((moveX * 32) << 16);
        nextMapY = GetActorY(0) + ((moveY * 32) << 16);

        if (buttons & BT_JUMP)  // walking only
        {
            moveSpeed = 8;
        }
        else
        {
            moveSpeed = 4;
        }

        // (buttons & BT_USE) || (buttons & BT_ALTATTACK) || (buttons & BT_JUMP)

    }

    if (GetActorX(0) == nextMapX && GetActorY(0) == nextMapY)
    {
        canHeroMove = !screenChanging;
        moveX = 0;
        moveY = 0;
        heroMapState = 1;
        heroMapStateTics = 0;

        if (!screenChanging)
        {
            if ((buttons & BT_FORWARD) && !(buttons & BT_BACK))  // look up
            {
                heroDirection = "u";
            }
            else if ((buttons & BT_BACK) && !(buttons & BT_FORWARD))  // look down
            {
                heroDirection = "d";
            }
            else if ((buttons & BT_MOVELEFT) && !(buttons & BT_MOVERIGHT))  // look left
            {
                heroDirection = "l";
            }
            else if ((buttons & BT_MOVERIGHT) && !(buttons & BT_MOVELEFT))  // look right
            {
                heroDirection = "r";
            }
        }
    }
    else
    {
        SetActorVelocity(0, (moveX << 16) * moveSpeed, (moveY << 16) * moveSpeed, 0, 0, 0);

        heroMapStateTics++;
        if (heroMapStateTics > ((32 / moveSpeed) / 2))
        {
            heroMapState = 1;
        }
        else
        {
            heroMapState = 2;
        }
    }
}

function int get_map_size(void)
{
    switch(currentMapNum)
    {
        case 1:
            return 4096;
    }

    return -1;
}

function str get_map_graphic(void)
{
    switch(currentMapNum)
    {
        case 1:
            return "world";
    }

    return "";
}

function void mapDisplayCoordinates(int x, int y)
{
    mapCoordinateX = mapDisplayX - ((mapSize / 2) << 16) + (x << 16);
    mapCoordinateY = mapDisplayY - ((mapSize / 2) << 16) + (y << 16);
}

function void map_objects(void)
{
    switch(currentMapNum)
    {
        case 1:
            map01_world_objects();
            return;
    }
}

function void check_map_points(void)
{
    switch(currentMapNum)
    {
        case 1:
            map01_world_points();
            return;
    }
}